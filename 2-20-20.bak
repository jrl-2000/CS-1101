;; The first three lines of this file were inserted by DrRacket. They record metadata
;; about the language level of this file in a form that our tools can easily process.
#reader(lib "htdp-intermediate-reader.ss" "lang")((modname 2-20-20) (read-case-sensitive #t) (teachpacks ()) (htdp-settings #(#t constructor repeating-decimal #f #t none #f () #t)))
(define-struct person (name year eye children))
;; a Person is a (make-person String Natural String ListOfPerson)
;; interp:  represents a person at the root of a descendant family tree
;;   where
;;     name is the person's name
;;     year is their year of birth
;;     eye is their eye color
;;     children is a list of the person's children


;; a ListOfPerson is one of
;;     empty
;;     (cons Person ListOfPerson)


(define SUSANTREE
  (make-person "Susan" 1920 "blue"
               (list (make-person "Joe" 1938 "green" empty)
                     (make-person "Helen" 1940 "brown"
                                  (list (make-person "Beth" 1965 "green" empty)
                                        (make-person "Sam" 1969 "brown" empty)))
                     (make-person "Ricky" 1942 "blue" empty))))

; ;; person-fcn:  Person ->
; ;;
; (define (person-fcn aper)
;   (... (person-name aper)
;        (person-year aper)
;        (person-eye aper)
;        (lop-fcn (person-children aper))))
; 
; 
; ;; lop-fcn:  ListOfPerson ->
; ;;
; (define (lop-fcn alop)
;   (cond [(empty? alop) (...)]
;         [(cons? alop) (...     (person-fcn (first alop))
;                                (lop-fcn (rest alop)))]))
; 


;; solving find-person using local

;; find-person:  String Person -> Person or false
;; consumes the name of a person and a person, and produces the person
;; in the tree with the given name, or produces false if no such named
;; person in the tree
(define (find-person name aper)
  (if (string=? name (person-name aper))
      aper
      (find-in-list name (person-children aper))))


;; find-in-list:  String ListOfPerson -> Person or false
;; consumes the name of a person and a list of persons and produces the
;; person in the list with the given name, or produces false if no such
;; named person in the list
(define (find-in-list name alop)
  (cond [(empty? alop) false]
        [(cons? alop) (local [(define FIND-PERSON-RESULT (find-person name (first alop)))]
                        (if (person? FIND-PERSON-RESULT)
                            FIND-PERSON-RESULT
                            (find-in-list name (rest alop))))]))

(check-expect (find-person "Debra" SUSANTREE) false)
(check-expect (find-person "Helen" SUSANTREE)
              (make-person "Helen" 1940 "brown"
                           (list (make-person "Beth" 1965 "green" empty)
                                 (make-person "Sam" 1969 "brown" empty))))
(check-expect (find-person "Sam" SUSANTREE) (make-person "Sam" 1969 "brown" empty))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


; ;; extract-positives:  ListOfNumber -> ListOfNumber
; ;; consumes a list of numbers and produces a list of only the positive numbers
; (define (extract-positives alon)
;   (cond [(empty? alon) empty]
;         [(cons? alon) (if (positive? (first alon))
;                           (cons (first alon) (extract-positives (rest alon)))
;                           (extract-positives (rest alon)))]))
; 
; 
; ;; short-strings:  ListOfString -> ListOfString
; ;; consumes a list of strings and produces a list of only those strings
; ;; that have fewer than 5 characters
; (define (short-strings alos)
;   (cond [(empty? alos) empty]
;         [(cons? alos) (if (< (string-length (first alos)) 5)
;                           (cons (first alos) (short-strings (rest alos)))
;                           (short-strings (rest alos)))]))
; 


; ;; HERE'S HOW filter IS DEFINED, BUT
; ;; YOU DON'T HAVE TO DEFINE filter; IT'S BUILT INTO RACKET
; 
; ;; filter:  (Alpha -> Boolean) ListOfAlpha -> ListOfAlpha
; ;; consumes a predicate and a list of alpha and produces a list of only those
; ;; alphas for which the given predicate is true
; (define (filter keep? aloa)
;   (cond [(empty? aloa) empty]
;         [(cons? aloa) (if (keep? (first aloa))
;                           (cons (first aloa) (filter keep? (rest aloa)))
;                           (filter keep? (rest aloa)))]))


;; extract-positives:  ListOfNumber -> ListOfNumber
;; consumes a list of numbers and produces a list of only the positive numbers
(define (extract-positives alon)
  (filter positive? alon))


;; short-strings:  ListOfString -> ListOfString
;; consumes a list of strings and produces a list of only those strings
;; that have fewer than 5 characters
(define (short-strings alos)
  (filter short? alos))

;; short?:  String -> Boolean
;; consumes a string and produces true if it has fewer than 5 characters
(define (short? a-str)
  (< (string-length a-str) 5))

;; try this problem tonight using filter

;; strings-shorter-than:  ListOfString Natural -> ListOfString
;; consumes a list of strings and a limit on the string length, and
;; produces a list of only those strings with fewer than the limit
;; number of characters